// contracts/coordinator/OutgoingCoordinator.sol
// SPDX-License-Identifier: MIT
pragma solidity >=0.8.0;

import "@openzeppelin/contracts/utils/Counters.sol";

/// @title Augmint CrossChain Protocol Coordinator for Outgoing Requests.
/// @author SaratAngajala.
/// @notice This contract handles aggregation of outgoing requests. 
/// @dev Primary Augmint Coordinator is supposed to extend this contract.
contract OutgoingCoordinator {
	using Counters for Counters.Counter;

	enum OutgoingRequestStatus {
		NOT_INITIATED,
		PENDING,
		FULLFILL_SUCCESS_CALLBACK_SUCCESS,
		FULLFILL_SUCCESS_CALLBACK_FAIL,
		FULLFILL_FAIL_CALLBACK_SUCCESS,
		FULLFILL_FAIL_CALLBACK_FAIL
	}

	enum OutgoingRequestTypes {
		CONTRACT_WRITE_REQUEST,
		NATIVE_PAYMENT_REQUEST,
		CONTRACT_READ_REQUEST,
		TOKEN_PAYMENT_REQUEST,
		BALANCE_QUERY_REQUEST
	}

	struct OutgoingRequest {
		OutgoingRequestTypes requestType;
		OutgoingRequestStatus status;
		address callbackAddress;
		string callbackSelector;
		uint256 requestId;
	}

	Counters.Counter private outgoingRequestIds;
	mapping(uint256 => OutgoingRequest) private outgoingRequests;

	/// @notice Event for oracles to identify new read request.
	/// @param chainId EIP-155 id for the target chain.
	/// @param contractAddress Address of the contract to interact with on the target chain.
	/// @param callData Byte array of encoded calldata which can be generated by using abi.encodeCall(functionSignature,...arguments).
	/// @param requestId Indexed uint256 unique identifier for the request.
	event ContractReadRequestInitated(
		uint256 indexed requestId,
		uint256 chainId,
		address contractAddress,
		bytes callData
	);

	/// @notice Event for oracles to identify new write request.
	/// @param chainId EIP-155 id for the target chain.
	/// @param contractAddress Address of the contract to interact with on the target chain.
	/// @param callData Byte array of encoded calldata which can be generated by using abi.encodeCall(functionSignature,...arguments).
	/// @param signer Address of the user that is supposed to sign the contract on target chain.
	/// @param requestId Indexed uint256 unique identifier for the request.
	event ContractWriteRequestInitated(
		uint256 indexed requestId,
		uint256 chainId,
		address contractAddress,
		bytes callData,
		address signer
	);

	/// @notice Event for oracles to identify a native coin payment request.
	/// @param requestId Indexed uint256 unique identifier for the request.
	/// @param chainId EIP-155 id for the target chain.
	/// @param recepientAddress Address to recieve the payment to.
	/// @param amount Amount to be recieved to the provided address.
	event NativePaymentRequestInitiated(
		uint256 indexed requestId,
		uint256 chainId,
		address recepientAddress,
		uint256 amount
	);

	/// @notice Event for oracles to identify a ERC20 token payment request.
	/// @param requestId Indexed uint256 unique identifier for the request.
	/// @param chainId EIP-155 id for the target chain.
	/// @param tokenAddress Address of the contract for the token to recieve.
	/// @param recepientAddress Address to recieve the payment to.
	/// @param amount Amount to be recieved to the provided address.
	event TokenPaymentRequestInitiated(
		uint256 indexed requestId,
		uint256 chainId,
		address tokenAddress,
		address recepientAddress,
		uint256 amount
	);

	/// @notice Event for oracles to identify a balance query request.
	/// @param requestId Indexed uint256 unique identifier for the request.
	/// @param chainId EIP-155 id for the target chain.
	/// @param queryAddress Address to query balance for.
	event BalanceQueryRequestInitated(
		uint256 indexed requestId,
		uint256 chainId,
		address queryAddress
	);

	/// @notice Event emitted when a request is fullfilled.
	/// @param requestId Indexed uint256 unique identifier for the request.
	/// @param isFulfillmentSuccessful Indexed boolean to indicate success/failure of fulfillment.
	/// @param isCallbackSuccessful Indexed boolean to indicate success/failure of callback.
	/// @param returnData Byte array of any data returned by comutation on target chain.
	event RequestFulfilled(
		uint256 indexed requestId,
		bool indexed isFulfillmentSuccessful,
		bool indexed isCallbackSuccessful,
		bytes returnData
	);

	/// @notice Initiates a read request, should come from the AugmintExternalContract contract.
	/// @dev Initiates a read request and emits and event for oracles to listen to.
	/// @param chainId EIP-155 id for the target chain.
	/// @param targetContractAddress Address of the contract to interact with on the target chain.
	/// @param callData Byte array of encoded calldata which can be generated by using abi.encodeCall(functionSignature,...arguments).
	/// @param callbackAddress Address of the contract the callback is on.
	/// @param callbackSelector Selector of the callback function.
	/// @return requestId A uint256 unique identifier for the request.
	function initiateContractReadRequest(
		uint256 chainId,
		address targetContractAddress,
		bytes calldata callData,
		address callbackAddress,
		string calldata callbackSelector
	) external returns (uint256 requestId) {
		requestId = outgoingRequestIds.current();
		outgoingRequestIds.increment();

		outgoingRequests[requestId] = OutgoingRequest({
			requestType: OutgoingRequestTypes.CONTRACT_READ_REQUEST,
			requestId: requestId,
			status: OutgoingRequestStatus.PENDING,
			callbackAddress: callbackAddress,
			callbackSelector: callbackSelector
		});

		emit ContractReadRequestInitated(requestId, chainId, targetContractAddress, callData);
	}

	/// @notice Initiates a write request, should come from the AugmintExternalContract contract.
	/// @dev Initiates a write request and emits and event for oracles to listen to.
	/// @param chainId EIP-155 id for the target chain.
	/// @param targetContractAddress Address of the contract to interact with on the target chain.
	/// @param callData Byte array of encoded calldata which can be generated by using abi.encodeCall(functionSignature,...arguments).
	/// @param signer Address of the user that is supposed to sign the contract on target chain.
	/// @param callbackAddress Address of the contract the callback is on.
	/// @param callbackSelector Selector of the callback function.
	/// @return requestId A uint256 unique identifier for the request.
	function initiateContractWriteRequest(
		uint256 chainId,
		address targetContractAddress,
		bytes calldata callData,
		address signer,
		address callbackAddress,
		string calldata callbackSelector
	) external returns (uint256 requestId) {
		requestId = outgoingRequestIds.current();
		outgoingRequestIds.increment();

		outgoingRequests[requestId] = OutgoingRequest({
			requestType: OutgoingRequestTypes.CONTRACT_WRITE_REQUEST,
			requestId: requestId,
			status: OutgoingRequestStatus.PENDING,
			callbackAddress: callbackAddress,
			callbackSelector: callbackSelector
		});

		emit ContractWriteRequestInitated(
			requestId,
			chainId,
			targetContractAddress,
			callData,
			signer
		);
	}

	/// @notice Initiates a payment request for payment in native token, should come from the AugmintExternalContract contract.
	/// @param chainId EIP-155 id for the target chain.
	/// @param recepientAddress Address to recieve the payment to.
	/// @param amount Amount to be recieved as payment.
	/// @param callbackAddress Address of the contract the callback is on.
	/// @param callbackSelector Selector of the callback function.
	/// @return requestId A uint256 unique identifier for the request.
	function initiateNativePaymentRequest(
		uint256 chainId,
		address recepientAddress,
		uint256 amount,
		address callbackAddress,
		string calldata callbackSelector
	) external returns (uint256 requestId) {
		requestId = outgoingRequestIds.current();
		outgoingRequestIds.increment();

		outgoingRequests[requestId] = OutgoingRequest({
			requestType: OutgoingRequestTypes.NATIVE_PAYMENT_REQUEST,
			requestId: requestId,
			status: OutgoingRequestStatus.PENDING,
			callbackAddress: callbackAddress,
			callbackSelector: callbackSelector
		});

		emit NativePaymentRequestInitiated(requestId, chainId, recepientAddress, amount);
	}

	/// @notice Initiates a payment request for payment in native token, should come from the AugmintExternalContract contract.
	/// @param chainId EIP-155 id for the target chain.
	/// @param tokenAddress Address of the contract for the token to recieve.
	/// @param recepientAddress Address to recieve the payment to.
	/// @param amount Amount to be recieved as payment.
	/// @param callbackAddress Address of the contract the callback is on.
	/// @param callbackSelector Selector of the callback function.
	/// @return requestId A uint256 unique identifier for the request.
	function initiateTokenPaymentRequest(
		uint256 chainId,
		address tokenAddress,
		address recepientAddress,
		uint256 amount,
		address callbackAddress,
		string calldata callbackSelector
	) external returns (uint256 requestId) {
		requestId = outgoingRequestIds.current();
		outgoingRequestIds.increment();

		outgoingRequests[requestId] = OutgoingRequest({
			requestType: OutgoingRequestTypes.TOKEN_PAYMENT_REQUEST,
			requestId: requestId,
			status: OutgoingRequestStatus.PENDING,
			callbackAddress: callbackAddress,
			callbackSelector: callbackSelector
		});

		emit TokenPaymentRequestInitiated(
			requestId,
			chainId,
			tokenAddress,
			recepientAddress,
			amount
		);
	}

	/// @notice Once a request has been fullfilled off the chain, result is to be committed here.
	/// @dev Validates the request being fulfilled and calls the provided callback address using provided callback selector.
	/// @param requestId Id of the request being fulfilled.
	/// @param isFulfillmentSuccess Boolean flag to indicate success/failure of the request.
	/// @param returnData Any data returned by the computation on target chain.
	function fullfillRequest(
		uint256 requestId,
		bool isFulfillmentSuccess,
		bytes calldata returnData
	) external {
		require(
			outgoingRequests[requestId].status == OutgoingRequestStatus.PENDING,
			"AugmintCoordinator: OutgoingRequest already fulfilled"
		);

		OutgoingRequest storage request = outgoingRequests[requestId];

		(bool isCallbackSuccessful, ) = request.callbackAddress.call(
			abi.encodeWithSignature(
				request.callbackSelector,
				requestId,
				isFulfillmentSuccess,
				returnData
			)
		);

		if (isFulfillmentSuccess) {
			request.status = isCallbackSuccessful
				? OutgoingRequestStatus.FULLFILL_SUCCESS_CALLBACK_SUCCESS
				: OutgoingRequestStatus.FULLFILL_SUCCESS_CALLBACK_FAIL;
		} else {
			request.status = isCallbackSuccessful
				? OutgoingRequestStatus.FULLFILL_FAIL_CALLBACK_SUCCESS
				: OutgoingRequestStatus.FULLFILL_FAIL_CALLBACK_FAIL;
		}

		emit RequestFulfilled(requestId, isFulfillmentSuccess, isCallbackSuccessful, returnData);
	}
    
    function getOutgoingRequestStatus(uint256 requestId) external view returns (OutgoingRequest memory) {
        return outgoingRequests[requestId]; 
    }
}
